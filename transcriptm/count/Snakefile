onsuccess:
    print("\u001b[42mCOMPLETE: TranscriptM successfully finished\u001b[0m")

onerror:
    print("\u001b[41mERROR: TranscriptM failed\u001b[0m")

onstart:
    import os
    import sys

    from snakemake.utils import logger, min_version

    # minimum required snakemake version
    min_version("6.5.3")
    short_reads_1 = config["short_reads_1"]
    short_reads_2 = config["short_reads_2"]
    genome_dir = config["genome_dir"]
    fasta_extension = config["fasta_extension"]
    n_cores = config["n_cores"]
    output = config["output"]
    ref = config["ref"]
    gff = config["gff"]
    max_memory = config["max_memory"]
    human_db = config["human_db"]
    silva_db = config["silva_db"]
    trimmomatic = config["trimmomatic"]
    sequencer_source = config["sequencer_source"]
    kingdom = config["kingdom"]
    skip_qc = config["skip_qc"]
    min_read_aligned_percent = config["min_read_aligned_percent"]
    min_read_percent_identity = config["min_read_percent_identity"]
    gDNA = config["gDNA"]

rule all:
    input:
        "qc/done",
        "annotate/done",
        "coverm/done",
        "coverm_filter/done",
        "detect_contam/done",
        "filter_contam/done",
        "final_bam/done",
        "feature_count/done"
    threads:
        config["n_cores"]
    resources:
        mem_gb = config["max_memory"]

rule qc:
    input:
    output:
        "qc/done"
    conda:
        "../envs/qc.yaml"
    threads:
        config["n_cores"]
    resources:
        mem_gb = config["max_memory"]
    message:
        "Performing read QC..."
    script:
        "../scripts/qc.py"

rule annotate:
    input:
        "qc/done"
    output:
        "annotate/done"
    conda:
        "../envs/annotate.yaml"
    threads:
        config["n_cores"]
    resources:
        mem_gb = config["max_memory"]
    message:
        "Creating reference .fna and .gff files..."
    script:
        "../scripts/annotate.py"

rule coverm:
    input:
        'annotate/done'
    output:
        "coverm/done",
    conda:
        "../envs/coverm.yaml"
    threads:
        config["n_cores"]
    resources:
        mem_gb = config["max_memory"]
    params:
        fna_file = 'annotate/combined_reference.fna',
        qc_reads_1 = 'qc/clean_reads/R1/*',
        qc_reads_2 = 'qc/clean_reads/R2/*',
        bam = os.path.join('coverm/*.bam')
    message:
        "Aligning reads to reference sequences..."
    shell:
        "echo R1 = {params.qc_reads_1} && "
        "echo R2 = {params.qc_reads_2} && "
        "coverm make -r {params.fna_file} -1 {params.qc_reads_1} -2 {params.qc_reads_2} -t {threads} -o coverm && "
        "mv {params.bam} coverm/combined_reference.bam && "
        "touch coverm/done"

rule coverm_filter:
    input:
        'coverm/done'
    output:
        "coverm_filter/done",
    conda:
        "../envs/coverm.yaml"
    threads:
        config["n_cores"]
    resources:
        mem_gb = config["max_memory"]
    params:
        bam = 'coverm/combined_reference.bam',
        min_read_aligned_percent = config["min_read_aligned_percent"],
        min_read_percent_identity = config["min_read_percent_identity"]
    message:
        "Filtering read alignments..."
    shell:
        "coverm filter \
        --bam-files {params.bam} \
        --output-bam-files coverm_filter/combined_reference_filtered.bam \
        --threads {threads} \
        --min-read-aligned-percent {params.min_read_aligned_percent} \
        --min-read-percent-identity {params.min_read_percent_identity} \
        --proper-pairs-only \
        --exclude-supplementary && "

        "samtools index coverm_filter/combined_reference_filtered.bam && "
        "touch coverm_filter/done"

rule detect_contam:
    input:
        'coverm_filter/done'
    output:
        "detect_contam/done"
    conda:
        "../envs/contam.yaml"
    threads:
        config["n_cores"]
    resources:
        mem_gb = config["max_memory"]
    params:
        bam = 'coverm_filter/combined_reference_filtered.bam',
        gff = 'annotate/combined_reference.gff',
        gDNA = int(config["gDNA"]),
        gDNA_single_strand = int(config["gDNA"])/2
    message:
        "Threshold for gDNA contamination set at {params.gDNA}x median gDNA read coverage per genome\nDetecting gDNA contamination..."
    shell:
        #get genes on reverse strand - if no contam then no reads should be present on fwd strand
        "gff2bed < {params.gff} > detect_contam/temp.bed && "
        "awk '$8==\"CDS\"' detect_contam/temp.bed > detect_contam/temp.CDS.bed && "
        "awk '$6 == \"-\"' detect_contam/temp.CDS.bed > detect_contam/CDS.rev.bed && "

        #prepare file with overlapping ORFs. Avoid these regions when filtering contam.
        "intersectBed -a detect_contam/temp.CDS.bed -b detect_contam/temp.CDS.bed -S > detect_contam/out && "
        "cat detect_contam/out | awk '{{print $1 \"\\t\" $2 \"\t\" $3 \"\t\" $8}}' | sort -u > detect_contam/overlappedORFs.bed ; rm detect_contam/out && "

        #split the reads mapping to forward strand
        "samtools view -b -f 128 -F 16 {params.bam} > detect_contam/fwd1.bam && "
        "samtools view -b -f 64 -F 32 {params.bam} > detect_contam/fwd2.bam && "
        "samtools merge -f detect_contam/fwd.bam detect_contam/fwd1.bam detect_contam/fwd2.bam && "
        "samtools index detect_contam/fwd.bam && "

        #identify genomes with antisense reads. calculates median antisense coverage across all genes in a genome (fwd strand)...
        #...then extracts all contigs per genome for use in strandCheckR
        "bedtools coverage -hist -b detect_contam/fwd.bam -a detect_contam/CDS.rev.bed > detect_contam/temp1 && "
        "sed -i '/^all/d' detect_contam/temp1 && "
        "awk -F\"\t\" '{{print $1 \"\t\" $4 \"\t\" $11 * $12 / $13}}' detect_contam/temp1 > detect_contam/temp2 && "
        "cat detect_contam/temp2 | datamash -s -g1,2 sum 3 > detect_contam/temp3 && " #sum the values from bedtools hist to get the total coverage
        "cat detect_contam/temp3 | awk '{{print $1}}' | rev | cut -d '_' -f2- | rev > detect_contam/temp3_genomeID && " #get genome name, trims the last '_' separated field which represents contig number.
        "paste detect_contam/temp3_genomeID detect_contam/temp3 > detect_contam/temp4 && "
        "sort -k1,1 detect_contam/temp4 > detect_contam/temp4_sort && "
        "cat detect_contam/temp4 | datamash -s -g1 median 4 > detect_contam/temp5 && "
        "awk -F\"\t\" '$2 > {params.gDNA_single_strand} {{print $1}}' detect_contam/temp5 > detect_contam/contaminated_genome_list && "#0.5 median coverage on one strand equals 1x gDNA contam. Have this as a tunable parameter.
        "sort -k1,1 detect_contam/contaminated_genome_list > detect_contam/contaminated_genome_list_sort && "
        "join  detect_contam/contaminated_genome_list_sort detect_contam/temp4_sort > detect_contam/temp6 && "
        "cat detect_contam/temp6 | awk '{{print $2}}' | sort -u > detect_contam/contaminated_contigs_list && "
        #"awk -F\"\t\" '$2 > 0.4 {{print $1 \"\t\" $2}}' detect_contam/temp4 > detect_contam/comtaminated_genome_list_coverage && "

        #split the contaminated contigs into separate bam for strandCheckR
        "samtools view {params.bam} | awk '{{print $3}}' | sort -u > detect_contam/all_contigs && "
        "comm -3 detect_contam/all_contigs detect_contam/contaminated_contigs_list > detect_contam/non-contaminated_contigs_list && "
        "cat detect_contam/contaminated_contigs_list  | tr \"\n\" \" \" | xargs samtools view -bh {params.bam} > detect_contam/contam_contigs.bam && "
        "cat detect_contam/non-contaminated_contigs_list  | tr \"\n\" \" \" | xargs samtools view -bh {params.bam} > detect_contam/non-contam_contigs.bam && "
        "samtools index detect_contam/contam_contigs.bam && "
        "samtools index detect_contam/non-contam_contigs.bam && "

        #clean
        "rm detect_contam/temp*  detect_contam/fwd1* detect_contam/fwd2* && "
        "touch detect_contam/done"

rule filter_contam:
    input:
        "detect_contam/done"
    output:
        "filter_contam/done"
    conda:
        '../envs/filter_contam.yaml'
    threads:
        config["n_cores"]
    resources:
        mem_gb = config["max_memory"]
    params:
        in_bam = 'detect_contam/contam_contigs.bam',
        out_bam = 'filter_contam/decontam_contigs.bam',
        gff = 'annotate/combined_reference.gff',
        overlap_list = 'detect_contam/overlappedORFs.bed',
        contam_list = 'detect_contam/contaminated_contigs_list'
    message:
        "Filtering gDNA contamination, if any, from BAM..."
    script:
        "../scripts/strandcheckr.R"


rule finalise_bam:
    input:
        "filter_contam/done"
    output:
        "final_bam/done"
    conda:
        '../envs/contam.yaml'
    threads:
        config["n_cores"]
    resources:
        mem_gb = config["max_memory"]
#    params:
#        contam_bam = 'coverm_filter/combined_reference_filtered.bam',
#        non-contam_bam = 'filter_contam/decontaminated.bam'
    message:
        "Merging decontaminated contigs with other contigs..."
    shell:
        "if [ -s detect_contam/contaminated_contigs_list ]; then samtools merge detect_contam/non-contam_contigs.bam filter_contam/decontam_contigs.bam -o final_bam/final.bam ; fi && "
        "samtools index final_bam/final.bam && "
        "touch final_bam/done"

rule feature_count:
    input:
        "final_bam/done"
    output:
        "feature_count/done"
    conda:
        "../envs/feature_count.yaml"
    threads:
        config["n_cores"]
    resources:
        mem_gb = config["max_memory"]
    params:
        bam = 'final_bam/final.bam',
        gff = 'annotate/combined_reference.gff'
    message:
        "Counting reads..."
    shell:
        "featureCounts \
            -a {params.gff} \
            -o feature_count/feature_count_table \
            -F GTF \
            -T {threads} \
            -p \
            -M \
            -s 2 \
            --fraction \
            -t 'CDS' \
            --extraAttributes 'gene,product,db_xref,inference,UniProtKB' \
            -g 'ID' \
            {params.bam} && "

        "sed -i '1d' feature_count/feature_count_table && "

        "printf 'Read count output available at: '$PWD'/feature_count/feature_count_table\n\n' && "
        "ln -sf feature_count/feature_count_table feature_count_table  && "

        "touch feature_count/done"
